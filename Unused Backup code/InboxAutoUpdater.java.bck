package com.wipromail.sathesh.threads;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import android.content.Context;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.util.Log;

import com.wipromail.sathesh.R;
import com.wipromail.sathesh.application.InboxUpdaterStatus;
import com.wipromail.sathesh.application.MailApplication;
import com.wipromail.sathesh.cache.CacheInboxAdapter;
import com.wipromail.sathesh.constants.Constants;
import com.wipromail.sathesh.customexceptions.StoredDateIsNullException;
import com.wipromail.sathesh.ews.EWSConnection;
import com.wipromail.sathesh.ews.MailFunctions;
import com.wipromail.sathesh.ews.MailFunctionsImpl;
import com.wipromail.sathesh.service.data.EventType;
import com.wipromail.sathesh.service.data.ExchangeService;
import com.wipromail.sathesh.service.data.FindItemsResults;
import com.wipromail.sathesh.service.data.GetEventsResults;
import com.wipromail.sathesh.service.data.Item;
import com.wipromail.sathesh.service.data.ItemEvent;
import com.wipromail.sathesh.service.data.ItemId;
import com.wipromail.sathesh.service.data.ServiceLocalException;
import com.wipromail.sathesh.sync.SyncUsingPullSubscription;

public class InboxAutoUpdater
extends Thread implements Constants
{
	public static final String HANDLER_KEY_MESSAGE = "Message";
	public static final String HANDLER_KEY_MESSAGE_DETAILED = "MessageDetailed";
	public static final String HANDLER_KEY_PROGRESS = "Progress";
	public static final String HANDLER_KEY_STATUS = "Status";

	//these status messages are used by Handler and not be InboxUpdater status
	public static final String STATUS_ERROR = "Error";
	public static final String STATUS_RUNNING = "Running";
	public static final String STATUS_UPDATE_LIST = "UpdateListView";
	public static final String STATUS_SYNCED = "Synced";
	public static final String STATUS_SHOW_WARNING = "ShowWarning";

	private Bundle bundle;

	private Context context;
	public FindItemsResults<Item> findResults;
	private Handler handlerInbox;
	private InboxUpdaterStatus inboxUpdaterStatus;
	private Message msgInbox;
	private ExchangeService service;
	private SyncUsingPullSubscription ss;

	//private ArrayList<ItemId> newMailItems = new ArrayList<ItemId>();
	private ArrayList<ItemId> createdItems = new ArrayList<ItemId>();
	private ArrayList<ItemId> modifiedItems = new ArrayList<ItemId>();
	private ArrayList<ItemId> deletedItems = new ArrayList<ItemId>();
	
	private boolean isSatisfyingMinInterval =false;

	private boolean isChangeMadeToCache =false;


	private Date lastSyncDate=null;


	//	private FindItemsResults<Item> findItemResults = null;

	public boolean shutdownCurrentThread=false;
	private GetEventsResults events;

	public InboxAutoUpdater(Context context, Handler handlerInbox)
	{
		this.context = context;
		this.handlerInbox = handlerInbox;
	}


	private boolean cacheChangedItems(GetEventsResults changeCollection) throws ServiceLocalException, Exception 
	{
		isChangeMadeToCache =false;
	//	newMailItems.clear();
		createdItems.clear();
		modifiedItems.clear();
		deletedItems.clear();
		
		Log.d(TAG, "InboxAutoUpdater -> Entered cacheChangedItems");
		
		//write the mails thereby to cache
		if(null != changeCollection ){

			// Loop through all item-related events.
			for(ItemEvent itemEvent : changeCollection.getItemEvents())      
			{
				Log.d(TAG, "InboxAutoUpdater -> in the ItemEvent LOOP");
				/*if(itemEvent.getEventType()== EventType.NewMail)
				{
					Log.d(TAG, "InboxAutoUpdater -> adding item in new mail " + itemEvent.getItemId());
					newMailItems.add(itemEvent.getItemId());
				}*/

				if(itemEvent.getEventType()==EventType.Created)
				{  
					Log.d(TAG, "InboxAutoUpdater -> adding item in created mail " + itemEvent.getItemId());
					createdItems.add(itemEvent.getItemId());
				}
				else if(itemEvent.getEventType()==EventType.Deleted)
				{
					modifiedItems.add(itemEvent.getItemId());
				}
				else if(itemEvent.getEventType()==EventType.Modified)
				{
					deletedItems.add(itemEvent.getItemId());
				}


			}

			/*if(newMailItems.size() > 0){
				Log.d(TAG, "InboxAutoUpdater -> calling cache adapter for new mail items " + newMailItems);
				CacheInboxAdapter.writeCacheInboxDataItemIds(context, newMailItems, false);
				isChangeMadeToCache = true;
			}*/
			
			//actual cache happens now..
			if(createdItems.size() > 0){
				Log.d(TAG, "InboxAutoUpdater ->  created mail items size" + createdItems.size());
				Log.d(TAG, "InboxAutoUpdater -> calling cache adapter for created mail items" + createdItems);
				CacheInboxAdapter.writeCacheInboxDataItemIds(context, createdItems, false);
				isChangeMadeToCache = true;
			}
			if(modifiedItems.size() > 0){
				Log.d(TAG, "InboxAutoUpdater ->  created mail items size" + createdItems.size());
				//CODE YET TO IMPLEMENT
				isChangeMadeToCache = true;
			}
			if(deletedItems.size() > 0){
				Log.d(TAG, "InboxAutoUpdater ->  deletedItems mail items size" + createdItems.size());
				//CODE YET TO IMPLEMENT
				isChangeMadeToCache = true;
			}
			
		}
		else
		{
			Log.e(TAG, "InboxAutoUpdater-cacheChangedItems() -> Error while caching. changeCollection is null");
		}
		
		return isChangeMadeToCache;

	}


	private void recursiveSync(SyncUsingPullSubscription ss) throws Exception
	{

		if(shutdownCurrentThread){ threadExitPostProcess(); return;	}

		Log.d(TAG, "Entered recursive Sync");
		try
		{
			isSatisfyingMinInterval = MailApplication.isSatisfyingMinInterval(inboxUpdaterStatus.getLastSuccessfulSync(context));

		}
		catch(StoredDateIsNullException e){

			//never synced completely before.. its the first time sync
			isSatisfyingMinInterval = true;
		}

		if (isSatisfyingMinInterval)
		{
			//show the progress bar to the ui.
			Log.d(TAG, "InboxAutoUpdater -> Inside isSatisfyingMinInterval if condition ");
			updateUserInterface(getProgressString(context), "Calling Sync", 5, STATUS_RUNNING);

			//null check for status
			if ((inboxUpdaterStatus != null) && (inboxUpdaterStatus.getStatus() != null))
			{
				Log.d(TAG, "InboxAutoUpdater -> Inside inboxUpdaterStatus null check  if condition ");

				//check if some other process is already updating the inbox
				if (!(inboxUpdaterStatus.getStatus().equalsIgnoreCase(InboxUpdaterStatus.STATUS_RUNNING)))
				{
					Log.d(TAG, "InboxAutoUpdater -> Inside inboxUpdaterStatus.getStatus().equalsIgnoreCase(InboxUpdaterStatus.STATUS_RUNNING) if condition ");
					Log.d(TAG, "Calling the Sync Using State Variable method");
					inboxUpdaterStatus.setStatus(InboxUpdaterStatus.STATUS_RUNNING);
					inboxUpdaterStatus.setExecutionType(InboxUpdaterStatus.TYPE_AUTO_UPDATE);


					if(shutdownCurrentThread){ threadExitPostProcess(); return;	}


					//EWS Call
					events = ss.doSync(context, service);

					//check for emails after the date time received
					//findItemResults = ss.getLatestMails(context, service, new Date("11/17/2012"));		//actual sync

					//if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
							//dont shutdown this thread after calling doSync and before updating cache, 
							//becos doSync will lay a watermark and return the events. that events shld be updated in cache immedietely. otherwise it will result in loss of data
					
				//	if(isInboxInitialSyncDone(context)){

						//caching new events
						Log.d(TAG, "InboxAutoUpdater -> Calling cacheChangedItems.." );
						isChangeMadeToCache = cacheChangedItems(events);

						//updating the UI list view
						
						if(isChangeMadeToCache){
							updateUserInterface(getProgressString(context), "Updating the UI", 5, STATUS_UPDATE_LIST);
						}

					//}


					lastSyncDate = new Date();
					Log.d(TAG, "InboxAutoUpdater -> MailFunctions Sync done. Will call Sync again after long refresh rate");
					//say UI that the update is complete
					updateUserInterface(getUpdatedProgressString(context, lastSyncDate), lastSyncDate.toString(), 5, STATUS_SYNCED);
					inboxUpdaterStatus.setStatus(InboxUpdaterStatus.STATUS_DONE);
					inboxUpdaterStatus.setLastSuccessfulSync(context, lastSyncDate);
					inboxUpdaterStatus.setExecutionType(InboxUpdaterStatus.TYPE_AUTO_UPDATE);
					inboxUpdaterStatus.storeIsInboxInitialSyncDone(context, "Yes");

					if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
					Thread.sleep(INBOX_UPDATER_LONG_REFRESH_RATE);
					if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
					recursiveSync(ss);

				}

				else{
					//some other processing is running

					Log.i(TAG, "InboxAutoUpdater -> " + ((inboxUpdaterStatus.getExecutionType() != null) ? inboxUpdaterStatus.getExecutionType() : "Some other process ")  + " is already updating the inbox and InboxAutoUpdater cannot continue now and wil retry after some time.");
					Log.i(TAG, "InboxAutoUpdater will retry after " +INBOX_UPDATER_LONG_REFRESH_RATE/1000 + " secs");
					if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
					Thread.sleep(INBOX_UPDATER_LONG_REFRESH_RATE);
					if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
					recursiveSync(ss);
				}
			}
			else
			{
				//inboxUdpaterstatus is null
				Log.e(TAG, "InboxAutoUpdater -> Cannot get the status. inboxUpdaterStatus or inboxUpdaterStatus.getStatus()  is null");
				Log.d(TAG, "InboxAutoUpdater -> inboxUpdaterStatus=" + inboxUpdaterStatus);
				updateUserInterface(context.getString(R.string.inbox_updater_error , "asd"), "Cannot get status", 0, STATUS_ERROR);
				if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
				Thread.sleep(INBOX_UPDATER_LONG_REFRESH_RATE);
				if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
				recursiveSync(ss);
			}



		}

		else
		{
			// synced just recently before.. will wait for short time and try again..
			Log.d(TAG, "InboxAutoUpdater -> MailFunctions synced very recently. Waiting for minimum interval");
			if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
			Thread.sleep(INBOX_UPDATER_MIN_INTERVAL);
			if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
			recursiveSync(ss);
		}
	}

	private void updateUserInterface(String message, String messageDetailed, int progress, String status)
	{
		msgInbox = Message.obtain();
		bundle.putString(HANDLER_KEY_MESSAGE, message);
		bundle.putString(HANDLER_KEY_MESSAGE_DETAILED, messageDetailed);
		bundle.putInt(HANDLER_KEY_PROGRESS, progress);
		bundle.putString(HANDLER_KEY_STATUS, status);
		msgInbox.setData(bundle);
		handlerInbox.sendMessage(this.msgInbox);
	}

	private void updateUserInterface(String message, String messageDetailed, int progress, String status, Object obj)
	{
		msgInbox = Message.obtain();
		msgInbox.obj = obj;
		bundle.putString(HANDLER_KEY_MESSAGE, message);
		bundle.putString(HANDLER_KEY_MESSAGE_DETAILED, messageDetailed);
		bundle.putInt(HANDLER_KEY_PROGRESS, progress);
		bundle.putString(HANDLER_KEY_STATUS, status);
		msgInbox.setData(bundle);
		handlerInbox.sendMessage(this.msgInbox);
	}

	public void run()
	{
		try
		{
			Log.d(TAG, "InboxAutoUpdater -> Thread has started");
			service = EWSConnection.getServiceFromStoredCredentials(context);
			bundle = new Bundle();
			inboxUpdaterStatus = InboxUpdaterStatus.getInboxUpdater();

			ss = new SyncUsingPullSubscription();

			if(shutdownCurrentThread){ threadExitPostProcess(); return;	}
			recursiveSync(ss);
			if(shutdownCurrentThread){ threadExitPostProcess(); return;	}

		}
		catch (Exception e) {
			// TODO Auto-generated catch block
			handleGeneralException(e);
		}
		Log.i(TAG, "InboxSutoUpdater -> Thread exiting");

	}



	private void threadExitPostProcess() {
		// TODO Auto-generated method stub
		Log.d(TAG, "InboxAutoUpdater -> Thread exiting");
		inboxUpdaterStatus.setStatus(InboxUpdaterStatus.STATUS_INTERRUPTED);
	}


	private void handleGeneralException(Exception e) {
		// TODO Auto-generated method stub
		updateUserInterface(context.getString(R.string.inbox_updater_error), e.getMessage(), 5, STATUS_ERROR);
		inboxUpdaterStatus.setStatus(InboxUpdaterStatus.STATUS_ERROR);
		inboxUpdaterStatus.setExecutionType(InboxUpdaterStatus.TYPE_AUTO_UPDATE);
		e.printStackTrace();
	}

	private boolean isInboxInitialSyncDone(Context context) throws Exception{
		if(null != inboxUpdaterStatus){
			if( inboxUpdaterStatus.getIsInboxInitialSyncDone(context).equalsIgnoreCase("Yes") ){

				return true;
			}

		}
		return false;
	}


	private String getProgressString(Context context) throws Exception{
		//return (isInboxInitialSyncDone(context) ?context.getString(R.string.inbox_updater_progress): (context.getString(R.string.inbox_updater_initialsync_progress) + ++initialSyncPassCounter) );
		return context.getString(R.string.inbox_updater_progress);
	}


	private String getUpdatedProgressString(Context context, Date lastSyncDate){
		return context.getString(R.string.inbox_updater_success, (new SimpleDateFormat(TITLEBAR_UPDATED_DATEFORMAT)).format(lastSyncDate.getTime()));
	}
}

